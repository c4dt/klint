#ifndef GHOST_MAP_GH_INCLUDED
#define GHOST_MAP_GH_INCLUDED

// -- Contract API --

fixpoint option<v> ghostmap_get<k, v>(list<pair<k, v> > ghostmap, k key) {
  switch(ghostmap) {
    case nil:
      return none;
    case cons(h, t):
      return switch(h) {
        case pair(hk, hv):
          return hk == key ? some(hv) : ghostmap_get(t, key);
      };
  }
}

fixpoint list<pair<k, v> > ghostmap_set<k, v>(list<pair<k, v> > ghostmap, k key, v value) {
  return cons(pair(key, value), ghostmap);
}

fixpoint list<pair<k, v> > ghostmap_remove<k, v>(list<pair<k, v> > ghostmap, k key) {
  switch(ghostmap) {
    case nil:
      return nil;
    case cons(h, t):
      return switch(h) {
        case pair(hk, hv):
          return hk == key ? t : cons(h, ghostmap_remove(t, key));
      };
  }
}

// -- Proof API --

fixpoint bool ghostmap_distinct<k, v>(list<pair<k, v> > ghostmap) {
  return distinct(map(fst, ghostmap));
}

// -- Lemmas --

// See Verifast issue #19: this is required so Redux, VeriFast's default solver, doesn't accidentally forget things
lemma void __hack_note(bool b) requires b; ensures b; { }

lemma void ghostmap_set_preserves_other<k, v>(list<pair<k, v> > ghostmap, k key, v value, k other_key)
requires other_key != key;
ensures ghostmap_get(ghostmap_set(ghostmap, key, value), other_key) == ghostmap_get(ghostmap, other_key);
{
  switch(ghostmap) {
    case nil:
    case cons(h, t):
      switch(h) {
        case pair(hk, hv):
          ghostmap_set_preserves_other(t, key, value, other_key);
          if (hk != key) {
            assert ghostmap_get(ghostmap_set(t, key, value), other_key) == ghostmap_get(t, other_key);
            if (hk == other_key) {
              assert ghostmap_get(ghostmap_set(ghostmap, key, value), other_key) == some(hv);
            }
          }
      }
  }
}

lemma void ghostmap_remove_preserves_other<k, v>(list<pair<k, v> > ghostmap, k key, k absent_key)
requires absent_key != key;
ensures ghostmap_get(ghostmap_remove(ghostmap, key), absent_key) == ghostmap_get(ghostmap, absent_key);
{
  switch(ghostmap) {
    case nil:
    case cons(h, t):
      switch(h) {
        case pair(hk, hv):
          ghostmap_remove_preserves_other(t, key, absent_key);
      }
  }
}

lemma void ghostmap_set_new_preserves_distinct<k, v>(list<pair<k, v> > ghostmap, k key, v value)
requires true == ghostmap_distinct(ghostmap) &*&
         none == ghostmap_get(ghostmap, key);
ensures true == ghostmap_distinct(ghostmap_set(ghostmap, key, value));
{
  switch(ghostmap) {
    case nil:
    case cons(h, t):
      switch(h) {
        case pair(hk, hv):
          ghostmap_set_new_preserves_distinct(t, key, value);
          if (hk != key) {
            //__hack_note(none == ghostmap_get(t, hk)); // without this, none == ghostmap_get(t, hk) is unprovable after the lemma!
            ghostmap_set_preserves_other(t, key, value, hk);
          }
      }
  }
}

lemma void ghostmap_remove_cancels_set<k, v>(list<pair<k, v> > ghostmap, k key, v value)
requires none == ghostmap_get(ghostmap, key);
ensures ghostmap_remove(ghostmap_set(ghostmap, key, value), key) == ghostmap;
{
  switch(ghostmap) {
    case nil:
    case cons(h, t):
      switch(h) {
        case pair(hk, hv):
          ghostmap_remove_cancels_set(t, key, value);
      }
  }
}

// -- Auto lemmas --

lemma_auto(ghostmap_get(ghostmap, key)) void ghostmap_get_implies_mem1<k, v>(list<pair<k, v> > ghostmap, k key)
requires ghostmap_get(ghostmap, key) != none;
ensures true == mem(key, map(fst, ghostmap));
{
  switch(ghostmap) {
    case nil:
    case cons(h, t):
      switch(h) {
        case pair(hk, hv):
          if (hk != key) {
            ghostmap_get_implies_mem1(t, key);
          }
      }
  }
}

lemma_auto(ghostmap_get(ghostmap, key)) void ghostmap_get_implies_mem2<k, v>(list<pair<k, v> > ghostmap, k key)
requires ghostmap_get(ghostmap, key) == none;
ensures false == mem(key, map(fst, ghostmap));
{
  switch(ghostmap) {
    case nil:
    case cons(h, t):
      switch(h) {
        case pair(hk, hv):
          if (hk != key) {
            ghostmap_get_implies_mem2(t, key);
          }
      }
  }
}

lemma_auto(ghostmap_set(ghostmap, key, value)) void ghostmap_set_new_value_increases_length<k, v>(list<pair<k, v> > ghostmap, k key, v value)
requires ghostmap_get(ghostmap, key) == none;
ensures length(ghostmap_set(ghostmap, key, value)) == length(ghostmap) + 1;
{
  switch(ghostmap) {
    case nil:
    case cons(h, t):
      switch(h) {
        case pair(hk, hv):
          if (hk != key) {
            ghostmap_set_new_value_increases_length(t, key, value);
          }
      }
  }
}

lemma_auto(ghostmap_set(ghostmap, key, value)) void ghostmap_set_then_get<k, v>(list<pair<k, v> > ghostmap, k key, v value)
requires true;
ensures ghostmap_get(ghostmap_set(ghostmap, key, value), key) == some(value);
{
  switch(ghostmap) {
    case nil:
    case cons(h, t):
      switch(h) {
        case pair(hk, hv):
          ghostmap_set_then_get(t, key, value);
      }
  }
}

lemma_auto(ghostmap_remove(ghostmap, key)) void ghostmap_remove_preserves_distinct<k, v>(list<pair<k, v> > ghostmap, k key)
requires true == ghostmap_distinct(ghostmap);
ensures true == ghostmap_distinct(ghostmap_remove(ghostmap, key));
{
  switch(ghostmap) {
    case nil:
    case cons(h, t):
      switch(h) {
        case pair(hk, hv):
          ghostmap_remove_preserves_distinct(t, key);
          if (hk != key) {
            __hack_note(ghostmap_get(t, hk) == none);
            ghostmap_remove_preserves_other(t, key, hk);
          }
      }
  }
}

lemma_auto(ghostmap_remove(ghostmap, key)) void ghostmap_remove_unchanged_when_missing<k, v>(list<pair<k, v> > ghostmap, k key)
requires ghostmap_get(ghostmap, key) == none;
ensures ghostmap_remove(ghostmap, key) == ghostmap;
{
  switch(ghostmap) {
    case nil:
    case cons(h, t):
      switch(h) {
        case pair(hk, hv):
          if (hk != key) {
            ghostmap_remove_unchanged_when_missing(t, key);
          }
      }
  }
}

#endif
